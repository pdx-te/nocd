from flask import Flask, request, abort
import random
import os
import sys
import binascii
import argparse
import gi
import nocd
import nocpusher
import pyinotify
import fileEventHandler
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk
from threading import Thread


app = Flask(__name__)

# global var for the GTK window
bind_window = None
bind_number = None
bind_token  = None


# CONSTANT VALUES
NUM_CHARS_TOKEN = 30

# Creates a window using GTK and displays a random int between 1 and 10k
# This is used to bind the NOC CLI to the NOCd
def create_window(): 
    # Generate random number to show on the screen. The user should send a request
    # with the number to bind the user to the display
    global bind_number
    bind_number = random.randint(1, 10000)
    global bind_window 
    bind_window = Gtk.Window()
    label = Gtk.Label("<span size=\"400000\">" + str(bind_number) + "</span>")
    label.set_use_markup(True)
    bind_window.add(label)
    bind_window.show_all()
    gtk_thread = Thread(target=Gtk.main)
    gtk_thread.setDaemon(True)
    gtk_thread.start()

# Generates a random token with NUM_CHARS_TOKEN characters
def generate_token():
    global NUM_CHARS_TOKEN
    return str(binascii.hexlify(os.urandom(NUM_CHARS_TOKEN)))

# Verifies the provided token
def verify_token(token=None):
    global bind_token
    if token == bind_token:
      return True
    else:
      return False

# Endpoint to request the NOCd to bind to the requesting NOC CLI
@app.route("/bind-noc-display-request")
def bind_noc_display_request():
    create_window()
    global bind_token
    bind_token = generate_token()
    return "Request received. Please provide displayed bind number to receive auth token."

# Endpoint to reply to the NOCd with the provided token and random bind number
@app.route("/bind-noc-display/te-<int:random>")
def bind_noc_display_reply(random):

    # Get the string with the random number provided by the NOC Display user
    # and if it matches the string generated by bind_noc_display_request
    # close the window and start accepting commands
    global bind_window
    global bind_number
    global bind_token

    if random == bind_number:
      bind_window.destroy()
      Gtk.main_quit()
      return bind_token, 200
    
    else:
      abort(401)  

# Endpoint to stop the cycle
@app.route("/stop-cycle")
def stop_cycle():
    # Check provided token
    if not verify_token(str(request.headers['Token'])):
        abort(401)

    # Stop the cycle
    noc.stop_cycle_tab_thread()
    return 'Stopped cycling of dashboards.', 200

# Endpoint to start the cycle
@app.route("/start-cycle")
def start_cycle():
    # Check provided token
    if not verify_token(request.headers):
        abort(401)

    # Stop the cycle
    noc.start_cycle_tab_thread()
    return 200

# Endpoint to open new dashboard
@app.route("/new-dashboard/<url>")
def new_dashboard(url):

    # Check provided token
    if not verify_token(request.headers):
        abort(401)

    noc.open_dashboard(url)
    return 200

# # Endpoint to start NOCd
# @app.route("/start-nocd")
# def start_nocd():
#
#     # Check provided token
#     if not verify_token(request.headers):
#       abort(401)
#
#     # Start NOCd
#     noc_thread.start()

    

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='NOCanator 3000 - Keeping OPS teams in Sync.')
    parser.add_argument('--config', dest='config', action='store', default='config.json',
                        help='Path to JSON config file.')
    parser.add_argument('-s', dest='server', action='store_true', default=False,
                        help='Sets the app to run as the server (the dashboard pusher). Defaults to False (client mode)')
    parser.add_argument('-a', dest='host', action='store',
                        help='Sets the server address for the Nocpusher. Required if using client mode.')
    parser.add_argument('-p', dest='port', action='store', default=4455,
                        help='Sets the server port for the Nocpusher. Defaults to port 4455.')
    parser.add_argument('--profile', dest='profile', action='store',
                        help='Sets the NOC profile. Select the dashboards to display.Ex: SRE or NET')
    parser.add_argument('--cycle-freq', dest='cycleFrequency', action='store', default=60,
                        help='Sets the dashboard cycle frequency. Defaults to 60 seconds.')
    args = parser.parse_args()

    if args.host and not args.profile and not args.cycleFrequency:
        parser.error("NOCDisplays requires NOC profile and cycle frequency. "
                     "Add --profile with SRE and --cycle-freq with 60 (s) for example.")
        sys.exit(1)

    # Start the app
    if args.server is True:
        noc = nocpusher.Nocpusher(config_file=args.config)
        # The watch manager stores the watches and provides operations on watches
        wm = pyinotify.WatchManager()
        mask = pyinotify.IN_MODIFY  # watched events
        file_event_handler = fileEventHandler.EventHandler(noc)
        notifier = pyinotify.ThreadedNotifier(wm, file_event_handler)
        # Start the notifier from a new thread, without doing anything as no directory or
        # file are currently monitored yet.
        notifier.start()
        # Start watching a path
        wdd = wm.add_watch(args.config, mask)
        # Run the server's main method
        noc.run()
        # Stop the notifier's thread
        notifier.stop()
    else:

        # Create NOCd instance
        noc = nocd.Nocd(config_file=args.config, host=args.host, port=args.port, profile=args.profile,
                        cycleFrequency=float(args.cycleFrequency))

        # Create thread for API server
        api_thread = Thread(target=app.run)
        api_thread.setDaemon(True)
        api_thread.start()

        # Start the NOCd server
        noc.run()

    sys.exit(0)
